/*
 *      Copyright (C) 2004,2004  bmonthy@users.sourceforge.net
 *      Copyright (C) 2017       strassenbahn@pc1715.de
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  US
 *
 *
 *  $Id: env_lex.c,v 1.6 2005/04/26 12:56:57 bmonthy Exp $
 */


/*
 * env_lex.c: simple lexical analyzer.  I didn't want to use
 * a lexical generated by flex, as it uses too many global static
 * variables, and doesn't handle recursivity.
 *
 */

#include "env_lex.h"
#include "env_parser.h"

/*
 * lex rules.
 */

struct env_lex_rules_t
{
	int num;
	int start_cond;
	char* pattern;
	regex_t *regexp;
	int next_cond;
};

static struct env_lex_rules_t lex_rules[] =
{

/* initial condition */
	{0, 0,     "^[ #]+[^\n]*\n+",       NULL,  0 }, /* comment line */
	{1, 0,     "^[ \r\n]+",         NULL,  0 }, /* empty line   */
	{2, 0,     "env-set",           NULL,  1 },
	{3, 0,     "env-prepend",       NULL,  1 },
	{4, 0,     "env-append",        NULL,  1 },
	{5, 0,     "requires",          NULL,  1 },
	{6, 0,     "env-unset",         NULL,  1 },

/* condition 1 */

	{7, 1,     "[A-Za-z0-9_\\:/\\.-]+",      NULL,  1},
	{8, 1,     "\\$|\\{|\\}",                NULL,  1},
	{9, 1,     "[ \t]+",                     NULL,  1},
	{10, 1,     "\n",                        NULL,  0} /* go to initial condition */

};

#define NUMBER_OF_RULES ( (sizeof(lex_rules) / sizeof(struct env_lex_rules_t)))
#define GET_RULE(x)  ( (&(lex_rules[(x)])))



#define BUF_MAX 16*8192


/* creates a new env_lex_t* object. */

env_lex_t*
env_lex_new(const char* filename)
{
	env_lex_t* me;
	struct env_lex_rules_t* rule;
	int idx;

	me = (env_lex_t*) malloc (sizeof(env_lex_t));
	if (!me) return NULL;

	memset(me, 0, sizeof(env_lex_t));
	me->in = fopen(filename, "r");
	if (!me->in)
	{
		free(me);
		return NULL;
	}

	me->buffer = (char*) malloc (BUF_MAX);
	me->buffer_len = 0;
	memset(me->buffer, 0, BUF_MAX);
	me->cond = 0;

	/*
	 * compiles regular expressions, if needed
	 *
	 */

	for(idx=0; idx < NUMBER_OF_RULES ; idx++)
	{
		rule = GET_RULE(idx);
		if (! rule->regexp)
		{
			int err;

			rule->regexp = (regex_t*) malloc (sizeof(regex_t));
			if ( (err=regcomp(rule->regexp, rule->pattern, REG_EXTENDED)) !=0)
			{
#ifdef _DEBUG
				char re_error[1024];

				regerror(err, rule->regexp, re_error, sizeof(re_error));
				log_msg(LOG_ERR, "can't compile regex %s: %s", rule->pattern, re_error);
#endif
				abort();
			}
		}
	}

	return me;
}


/* reads next token, and put the value  in yylval */

int
yylex(YYSTYPE *yylval, env_lex_t* me)
{

	int bestrule_n;
	struct env_lex_rules_t* rule, *bestrule;
	int i;
	regmatch_t match[1], bestmatch;
	int err;

	/*
	 * fill buffer if needed
	 */

	if ((me->buffer_len < (BUF_MAX /2)) && (!me->eof))
	{
		size_t nb;
		nb = fread(me->buffer + me->buffer_len, 1, (BUF_MAX - me->buffer_len-2), me->in);
		if (!nb)
			me->eof = 1;
		else
			me->buffer_len += nb;
	}


	/* parse all rules, select the best one */


	while (1)
	{

		if (! me->buffer_len ) return EOF; /* EOF or error detected */

		bestrule=NULL;
		bestrule_n=-1;


	for(i=0; i < NUMBER_OF_RULES; i++)
	{
		rule = GET_RULE(i);

		if (rule->start_cond != me->cond) continue;

		err = regexec( rule->regexp, me->buffer, 1, match, 0);

		if (err == REG_NOMATCH) continue;
		if (match[0].rm_so != 0) continue;


		if ( (match[0].rm_eo - match[0].rm_so) > bestrule_n)
		{
			bestrule_n = match[0].rm_eo;
			bestrule=rule;
			bestmatch.rm_so = match[0].rm_so;
			bestmatch.rm_eo = match[0].rm_eo;
		}
	}


	if (bestrule)
	{
		int len;

		len  = bestmatch.rm_eo;	/* rm_so =  0 */
		snprintf(me->tmp, MAX_WORD_LEN, "%s", me->buffer);
		me->tmp[len]='\0';


		memmove(me->buffer, me->buffer + len, me->buffer_len -len);
		me->buffer_len -=len;
		*(me->buffer + me->buffer_len)='\0';

#if 0
		log_msg(LOG_DEBUG, "-- accepting rule %i for '%s'", bestrule->num, me->tmp);
#endif

		/* update next start condition */
		me->cond = bestrule->next_cond;

		switch (bestrule->num)
		{
	case 0:
	case 1:
		continue; /* ignore */

	case 2:
		return ENV_SET;
		break;

	case 3:
		return ENV_PREPEND;
		break;

	case 4:
		return ENV_APPEND;
		break;

	case 5:
		return ENV_APPEND;
		break;

	case 6:
		return ENV_UNSET;
		break;

	case 7:
		*yylval = strdup(me->tmp);
		return WORD;
		break;

	case 8:
		return me->tmp[0];
		break;

	case 9:
	case 10:
		continue ; /* ignore */
		}
	}

	else
	{
		char msg[1024];
		int i;

		for(i=0; i < me->buffer_len; i++) if (me->buffer[i]=='\n') { me->buffer[i]='\0'; break;}

		snprintf(msg, 1024, "unexpected token: '%s'. Aborting file parsing.", me->buffer);
		yyerror(msg);
		break;
	}
	}

	return EOF;
}


/* deletes env_lex_t object */

void
env_lex_free(env_lex_t* me)
{
	assert_ptr(me);

	free(me->buffer);
	fclose(me->in);
	free(me);

}



